# ++++++++++++++++++++++++++++++++++++++++++++++++
# Задания по теме isinstance(), filter()
# ++++++++++++++++++++++++++++++++++++++++++++++++
# ===============================================
# 1. Оставь только строки и списки из списка:
# items = [5, "hello", [1, 2], 3.14, {"a": 1}, "world"]
# Ожидаемый результат:
# ['hello', [1, 2], 'world']

# items = [5, "hello", [1, 2], 3.14, {"a": 1}, "world"]
# result = [n for n in items if isinstance(n, (str, list))]
# print(result)

# ===============================================
# 2. Создай функцию describe_type(x), которая:
# печатает "Это строка", если x — строка
# "Это число", если x — int или float
# "Это булевое значение", если x — bool
# "Неизвестный тип" — в остальных случаях
# Пример вызова:
# describe_type(5.5)       # Это число
# describe_type(True)      # Это булево значение
# describe_type("Привет")  # Это строка
# describe_type([1, 2, 3]) # Неизвестный тип

# def describe_type(x):
#     if isinstance(x, bool):
#         print("Это булевое значение")
#     elif isinstance(x, str):
#         print("Это строка")
#     elif isinstance(x, (int, float)):
#         print("Это число")
#     else:
#         print("Неизвестный тип")
#
# describe_type(5.5)  # Это число
# describe_type(True)  # Это булевое значение
# describe_type("Привет")  # Это строка
# describe_type([1, 2, 3]) # Неизвестный тип

# ===============================================
# 3. Создай функцию filter_list(f, data: list[int]) -> list[int],
# которая возвращает только те элементы из data, которые проходят проверку функцией f.
# Проверь на функции lambda x: x > 3 и списке [1, 3, 5, 7].

# def filter_list(f, date: list[int]) -> list[int]:
#     return [x for x in date if f(x)]
# result = filter_list(lambda x: x > 3, [1, 3, 5, 7])
# print(result)

# Ожидаемый результат:
# [5, 7]

# ===============================================
# 4. Добавь аннотацию типов в следующую функцию и укажи, что она возвращает None:
# def print_info(name, age, tags):
#     print(name, age, tags)

# def print_info(name: str, age: int, tags: list[str]) -> None:
#     print(name, age, tags)
#
# print_info("Мария", 45, [])
# print_info("Nelly", "38", ["test"])

# ===============================================
# 5. Создай функцию def analyze(data),
# которая выводит количество элементов и среднее значение, если список не пустой.

# def analyze(data):
#     if len(data) > 0:
#         count = len(data)
#         average = sum(data) / count
#         print(f"Количество элементов: {count}")
#         print(f"Среднеее значение: {average}")
#     else:
#         print("Список пустой")
#
# analyze([10, 20, 30])
# analyze([])

# ===============================================
# ++++++++++++++++++++++++++++++++++++++++++++++++
# Задания по теме all() и any()
# ++++++++++++++++++++++++++++++++++++++++++++++++
# ===============================================
# 6. Список логических значений:
# flags = [True, True, True, False]
# Проверь:
# Все ли значения истинные
# Есть ли среди них хотя бы одно истинное
# Ожидаемый результат:
# False
# True

flags = [True, True, True, False]

# Все ли значения истинные:
# all_true = all(flags)
# print(all(flags))

# Есть ли среди них хотя бы одно истинное:
# any_true = any(flags)
# print(any(flags))

# Ожидаемый результат:
# False
# True

# ===============================================
# 7. Поле в игре "Крестики-нолики" представлено так:
# field = ['x', 'x', 'x', 'o', 'o', '', '', '', '']
# Проверь, победил ли 'x' по первой строке.
# Ожидаемый результат:
# True

# field = ['x', 'x', 'x', 'o', 'o', '', '', '', '']
"""
          0    1    2    3    4    5   6   7   8
"""
# field_1 =field[0:3]  # ['x', 'x', 'x']
# print(all(cell == 'x' for cell in field_1))

# Ожидаемый результат:
# True

# ===============================================
# 8. На поле для "Сапёра" находится мина, если в ячейке символ *. Есть ли мина?
# P = ['0', '0', '0', '*', '0']
# Ожидаемый результат:
# True

# P = ['0', '0', '0', '*', '0']
# print(any(cell == '*' for cell in P)) # Возвращает True, так как в ячейке есть одна мина(символ *)

# Ожидаемый результат:
# True

# ===============================================
# ++++++++++++++++++++++++++++++++++++++++++++++++
# Задания по теме random
# ++++++++++++++++++++++++++++++++++++++++++++++++
# ===============================================
# 9. Выбери случайное значение из списка:
# colors = ["red", "green", "blue", "yellow", "purple"]
# Ожидаемый результат:
# Выбран цвет: blue

# import random
#
# colors = ["red", "green", "blue", "yellow", "purple"]
# N = random.choice(colors)
# print(f"Выбран цвет: {N}")

# Выбран цвет: green

# ===============================================
# 10. Сгенерируй 10 случайных чисел от 0 до 100 и выведи их. Сделай так, чтобы результат был одинаковый при каждом запуске.

# import random
#
# random.seed(88)
# N = [random.randint(0, 100) for _ in range(10)]
# print(N)

# Ожидаемый результат:
# [50, 24, 42, 23, 80, 1, 67, 98, 89, 1]

# ===============================================
# ++++++++++++++++++++++++++++++++++++++++++++++++
# Задания по теме "Аннотация типов в Python"
# ++++++++++++++++++++++++++++++++++++++++++++++++
# ===============================================
# 11. Напиши функцию greet(), которая принимает строку name и возвращает строку Привет, <name>!.
# Добавь аннотацию типов.
# Ожидаемый вывод:
# Привет, Анна!

# def greet(name: str) -> str:
#     return f"Привет, {name}!"
# print(greet("Kate"))

# Ожидаемый вывод:
# Привет, Kate!

# ===============================================
# 12. Создай функцию multiply(a, b), которая принимает два числа int или float и возвращает их произведение.
# Добавь аннотацию типов.
# Ожидаемый вывод:
# 20

# def multiply(a: float, b: float) -> float:
#     return a * b
# print(multiply(4, 5))

# Ожидаемый вывод:
# 20

# 13. Проверь типы аргументов функции через __annotations__.
# Создай функцию area(length: float, width: float) -> float и распечатай её аннотации.
# Ожидаемый вывод:
# {'length': <class 'float'>, 'width': <class 'float'>, 'return': <class 'float'>}

# def area(length: float, width: float) -> float:
#     return length * width
#
# print(area.__annotations__)
